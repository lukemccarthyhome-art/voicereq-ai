<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %> - Morti Projects</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-deep: #0a1628; --bg-primary: #0f1d32; --bg-card: #142640;
      --bg-glass: rgba(15, 29, 50, 0.6); --border-glass: rgba(255, 255, 255, 0.08);
      --border-glass-hover: rgba(255, 255, 255, 0.15);
      --accent: #1199fa; --accent-glow: rgba(17, 153, 250, 0.4); --accent-dim: rgba(17, 153, 250, 0.12);
      --accent-secondary: #009e7e; --accent-purple: #8b5cf6;
      --text-primary: #f0f4f8; --text-secondary: rgba(240, 244, 248, 0.7); --text-muted: rgba(240, 244, 248, 0.4);
      --radius: 16px; --radius-pill: 50px;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg-deep); color: var(--text-primary); line-height:1.6; -webkit-font-smoothing: antialiased; }
    a { text-decoration: none; color: inherit; }

    .main { max-width:900px; margin:0 auto; padding:32px 24px; }
    .back-link { font-size:0.82rem; color:var(--text-muted); margin-bottom:20px; }
    .back-link a { color:var(--accent); display:inline-flex; align-items:center; gap:6px; text-decoration:none; }
    .back-link a:hover { text-decoration:underline; }
    .badge { display:inline-block; padding:4px 12px; border-radius:var(--radius-pill); font-size:0.72rem; font-weight:600; text-transform:uppercase; }
    .badge-final { background:rgba(0,158,126,0.12); color:var(--accent-secondary); border: 1px solid rgba(0,158,126,0.3); }
    .btn { display:inline-flex; align-items:center; gap:6px; padding:10px 24px; border:none; border-radius:var(--radius-pill); font-weight:600; font-size:0.88rem; cursor:pointer; transition:all 0.3s; color:#fff; font-family:'Inter',sans-serif; }
    .btn-primary { background:var(--accent); box-shadow: 0 0 16px var(--accent-glow); }
    .btn-sm { padding:6px 14px; font-size:0.78rem; }

    .section-card { background: var(--bg-glass); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid var(--border-glass); border-radius: var(--radius); padding:24px 28px; margin-bottom:16px; transition: border-color 0.3s; }
    .section-card:hover { border-color: var(--border-glass-hover); }
    .section-card h3 { font-size:1rem; font-weight:700; color:var(--text-primary); margin-bottom:14px; display:flex; align-items:center; gap:10px; }
    .section-card h3 .icon { font-size:20px; }
    .section-body { font-size:0.88rem; color:var(--text-secondary); line-height:1.8; }
    .section-body p { margin-bottom:8px; }
    .section-body strong { color:var(--text-primary); }

    .step-flow { display:flex; flex-direction:column; gap:0; position:relative; padding-left:44px; }
    .step-flow::before { content:''; position:absolute; left:18px; top:24px; bottom:24px; width:2px; background:linear-gradient(to bottom, var(--accent), var(--accent-purple)); }
    .step-item { position:relative; padding:14px 0; }
    .step-num { position:absolute; left:-44px; top:14px; width:36px; height:36px; border-radius:50%; background:linear-gradient(135deg, var(--accent), var(--accent-purple)); color:#fff; display:flex; align-items:center; justify-content:center; font-size:0.88rem; font-weight:700; box-shadow:0 0 16px var(--accent-glow); z-index:1; }
    .step-title { font-weight:700; color:var(--text-primary); font-size:0.95rem; margin-bottom:4px; }
    .step-desc { color:var(--text-muted); font-size:0.88rem; line-height:1.6; }

    .question-card { padding:14px 18px; border-radius:12px; background:var(--bg-card); border:1px solid var(--border-glass); margin-bottom:12px; }
    .question-card .q-id { display:inline-block; background:var(--accent); color:white; width:26px; height:26px; border-radius:50%; text-align:center; line-height:26px; font-size:0.78rem; font-weight:700; margin-right:10px; }
    .question-card .q-text { font-weight:600; color:var(--text-primary); font-size:0.88rem; }
    .question-card .q-assumption { font-size:0.78rem; color:var(--text-muted); margin-top:4px; font-style:italic; }
    .question-card .q-answer { margin-top:8px; padding:8px 12px; background:rgba(0,158,126,0.1); border-radius:8px; color:var(--accent-secondary); font-size:0.82rem; }
    .answer-form { display:flex; gap:8px; margin-top:10px; }
    .answer-form input[type="text"] { flex:1; padding:10px 14px; border:1px solid var(--border-glass); border-radius:10px; font-size:0.88rem; background:rgba(5,13,26,0.6); color:var(--text-primary); font-family:'Inter',sans-serif; }
    .answer-form input[type="text"]:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }

    .design-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; margin-top:12px; }
    .design-item { padding:16px; border-radius:12px; background:var(--bg-card); border:1px solid var(--border-glass); }
    .design-item h4 { font-size:0.72rem; text-transform:uppercase; letter-spacing:0.08em; color:var(--accent); margin-bottom:6px; font-weight:600; }
    .full-width { grid-column: 1 / -1; }

    /* Tabs */
    .tabs { display:flex; gap:0; border-bottom:1px solid var(--border-glass); margin-bottom:20px; }
    .tab { padding:12px 24px; font-size:0.88rem; font-weight:600; color: var(--text-muted); cursor:pointer; border-bottom:2px solid transparent; margin-bottom:-1px; transition:all 0.2s; user-select:none; }
    .tab:hover { color: var(--text-secondary); }
    .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    .tab-content { display:none; }
    .tab-content.active { display:block; }

    /* Engine/Build Spec sections */
    .engine-section { background: var(--bg-card); border:1px solid var(--border-glass); border-radius:12px; padding:18px 22px; margin-bottom:14px; }
    .engine-section h4 { font-size:0.78rem; text-transform:uppercase; letter-spacing:0.05em; color: var(--accent); margin-bottom:10px; font-weight:700; }
    .engine-section .section-body { font-size:0.85rem; color: var(--text-secondary); }

    .empty-state { text-align:center; padding:24px; color: var(--text-muted); font-size:0.88rem; }

    @media (max-width:768px) {
      .design-grid { grid-template-columns:1fr; }
      .tabs { overflow-x:auto; }
      .tab { padding:10px 16px; font-size:0.82rem; white-space:nowrap; }
    }
  </style>
</head>
<body>
  <%- include('../partials/customer-nav', { currentPage: 'projects', user: user }) %>

  <main class="main">
    <div class="back-link">
      <a href="/projects/<%= encodeId(projectId) %>">‚Üê Back to project</a>
    </div>

    <%
      const hasNewFormat = !!(design.customerDesign || design.engineDesign);
      const customerDesign = design.customerDesign || null;
      let designSections = design.sections || null;
      let designSummary = design.summary || '';
    %>

    <!-- Approval Banner -->
    <% if (design.approvedAt) { %>
    <div style="padding:14px 18px;background:rgba(0,158,126,0.1);border:1px solid rgba(0,158,126,0.3);border-radius:var(--radius);margin-bottom:16px;display:flex;align-items:center;gap:10px;">
      <span style="font-size:22px;">‚úÖ</span>
      <div>
        <strong style="color:var(--accent-secondary);">Design Approved</strong>
        <span style="font-size:0.82rem;color:var(--text-secondary);"> ‚Äî by <%= design.approvedBy %> on <%= melb(design.approvedAt) %></span>
      </div>
    </div>
    <% } %>

    <!-- Header -->
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:24px;">
      <div>
        <h1 style="font-size:1.4rem;font-weight:800;letter-spacing:-0.03em;margin-bottom:4px;">üìê <%= project.name %> ‚Äî Solution Design</h1>
        <div style="font-size:0.82rem;color:var(--text-muted);">
          Published <%= design.publishedAt ? melb(design.publishedAt) : '' %>
          <% if (design.version) { %> ¬∑ v<%= design.version %><% } %>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <span class="badge badge-final">Published</span>
        <% if (!design.approvedAt) { %>
        <form method="POST" action="/customer/projects/<%= encodeId(projectId) %>/design/approve" onsubmit="return confirm('Approve this design? This confirms you are happy with the proposed solution.');" style="margin:0;">
          <button type="submit" class="btn" style="background:var(--accent-secondary);box-shadow:0 0 16px rgba(0,158,126,0.3);">‚úÖ Approve Design</button>
        </form>
        <% } %>
      </div>
    </div>

    <% if (hasNewFormat) { %>
      <%
      %>

      <!-- Tabbed layout -->
      <div class="tabs">
        <div class="tab active" data-tab="overview">üìã Design Overview</div>
        <div class="tab" data-tab="workflows">üîÑ Workflows</div>
        <div class="tab" data-tab="assets">üì¶ Assets</div>
      </div>

      <!-- Design Overview Tab -->
      <div class="tab-content active" id="tab-overview">
        <% if (customerDesign) { %>
          <%
            const custSections = [
              { key: 'ExecutiveSummary', label: 'Executive Summary', icon: 'üìã' },
              { key: 'HowItWorks', label: 'How It Works', icon: '‚ö°' },
              { key: 'WhatYouGet', label: 'What You Get', icon: 'üéØ' },
              { key: 'WhatWeNeedFromYou', label: 'What We Need From You', icon: 'ü§ù' },
              { key: 'AutomatedVsManual', label: 'Automated vs Manual', icon: 'ü§ñ' }
            ];
            const custKeys = Object.keys(customerDesign);
            const extraCustKeys = custKeys.filter(k => !custSections.find(s => s.key === k));
          %>
          <% custSections.forEach(sec => { %>
            <% if (customerDesign[sec.key]) { %>
              <div class="section-card">
                <h3><span class="icon"><%= sec.icon %></span> <%= sec.label %></h3>
                <% if (sec.key === 'HowItWorks') { %>
                  <div class="step-flow" id="howItWorksFlow"></div>
                  <noscript><div class="section-body"><%- renderText(customerDesign[sec.key]) %></div></noscript>
                <% } else { %>
                  <div class="section-body"><%- renderText(customerDesign[sec.key]) %></div>
                <% } %>
              </div>
            <% } %>
          <% }) %>
          <% extraCustKeys.forEach(key => { %>
            <% if (customerDesign[key]) { %>
              <div class="section-card">
                <h3><%= key.replace(/([A-Z])/g, ' $1').trim() %></h3>
                <div class="section-body"><%- renderText(customerDesign[key]) %></div>
              </div>
            <% } %>
          <% }) %>
        <% } else { %>
          <div class="empty-state">No design overview sections generated yet.</div>
        <% } %>
      </div>

      <!-- Workflows Tab -->
      <div class="tab-content" id="tab-workflows">
        <% const workflows = design.workflows || []; %>
        <% if (workflows.length > 0) { %>
          <div style="display:grid;gap:16px;">
            <% workflows.forEach((wf, i) => { %>
              <div style="padding:20px;border-radius:12px;background:var(--bg-card);border:1px solid var(--border-glass);border-left:4px solid var(--accent);">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="background:var(--accent);color:white;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:0.8rem;font-weight:700;"><%- wf.id ? wf.id.replace('wf-','') : (i+1) %></span>
                  <h4 style="margin:0;color:var(--text-primary);font-size:1rem;"><%= wf.name %></h4>
                </div>
                <div style="display:grid;gap:8px;font-size:0.88rem;">
                  <div><strong style="color:var(--accent);">Trigger:</strong> <span style="color:var(--text-secondary);"><%= wf.trigger %></span></div>
                  <div style="color:var(--text-secondary);"><%- renderText(wf.summary || '') %></div>
                  <% if (wf.steps) { %><div style="margin-top:8px;"><%- renderText(wf.steps) %></div><% } %>
                  <% if (wf.outputsTo) { %><div style="margin-top:4px;"><strong style="color:var(--accent-purple);">&#8594; Outputs to:</strong> <span style="color:var(--text-secondary);"><%= wf.outputsTo %></span></div><% } %>
                </div>
              </div>
            <% }) %>
          </div>
        <% } else { %>
          <div class="empty-state">No workflows identified yet.</div>
        <% } %>
      </div>

      <!-- Assets Tab -->
      <div class="tab-content" id="tab-assets">
        <% const assets = design.assets || []; %>
        <% if (assets.length > 0) { %>
          <div style="display:grid;gap:16px;">
            <% assets.forEach(asset => { %>
              <div style="padding:20px;border-radius:12px;background:var(--bg-card);border:1px solid var(--border-glass);border-left:4px solid <%= asset.buildOrIntegrate === 'question' ? '#f59e0b' : (asset.buildOrIntegrate === 'build' ? '#009e7e' : '#8b5cf6') %>;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <h4 style="margin:0;color:var(--text-primary);font-size:0.95rem;"><%= asset.name %></h4>
                  <span style="font-size:0.72rem;padding:2px 10px;border-radius:20px;background:rgba(17,153,250,0.12);color:var(--accent);font-weight:600;"><%= asset.type %></span>
                  <% if (asset.buildOrIntegrate === 'question') { %>
                    <span style="font-size:0.72rem;padding:2px 10px;border-radius:20px;background:rgba(245,158,11,0.12);color:#f59e0b;font-weight:600;">Needs Clarification</span>
                  <% } else if (asset.buildOrIntegrate === 'build') { %>
                    <span style="font-size:0.72rem;padding:2px 10px;border-radius:20px;background:rgba(0,158,126,0.12);color:#009e7e;font-weight:600;">Build New</span>
                  <% } else { %>
                    <span style="font-size:0.72rem;padding:2px 10px;border-radius:20px;background:rgba(139,92,246,0.12);color:#8b5cf6;font-weight:600;">Integrate</span>
                  <% } %>
                </div>
                <div style="font-size:0.88rem;color:var(--text-secondary);margin-bottom:8px;"><%= asset.purpose %></div>
                <% if (asset.buildNotes) { %><div style="font-size:0.82rem;color:var(--text-muted);padding:10px;background:rgba(5,13,26,0.4);border-radius:8px;margin-bottom:8px;"><%- renderText(asset.buildNotes) %></div><% } %>
                <% if (asset.integrationNotes) { %><div style="font-size:0.82rem;color:#f59e0b;font-style:italic;"><%= asset.integrationNotes %></div><% } %>
                <% if (asset.linkedToWorkflows && asset.linkedToWorkflows.length) { %><div style="font-size:0.78rem;color:var(--text-muted);margin-top:6px;">Linked to: <%= asset.linkedToWorkflows.join(', ') %></div><% } %>
              </div>
            <% }) %>
          </div>
        <% } else { %>
          <div class="empty-state">No assets identified yet.</div>
        <% } %>
      </div>


    <% } else if (designSections) { %>
      <% if (designSummary) { %>
        <div style="padding:14px 18px;background:var(--accent-dim);border:1px solid rgba(17,153,250,0.2);border-radius:12px;font-size:0.88rem;color:var(--accent);margin-bottom:16px;">
          <strong>Summary:</strong> <%= designSummary %>
        </div>
      <% } %>
      <div class="design-grid">
        <%
          const sectionOrder = ['ExecutiveSummary','CoreWorkflow','SimplifiedArchitecture','MinimalDataModel','ManualVsAutomated','Assumptions','Dependencies','Phase2Enhancements','RisksAndMitigations','TechnicalReadiness','TechnicalReference'];
          const sectionLabels = { ExecutiveSummary:'Executive Summary', CoreWorkflow:'Core Workflow', SimplifiedArchitecture:'Simplified Architecture', MinimalDataModel:'Minimal Data Model', ManualVsAutomated:'Manual vs Automated', Assumptions:'Assumptions', Dependencies:'Dependencies', Phase2Enhancements:'Phase 2 Enhancements', RisksAndMitigations:'Risks & Mitigations', TechnicalReadiness:'Technical Readiness', TechnicalReference:'Technical Reference' };
          const fullWidthSections = ['ExecutiveSummary','CoreWorkflow','SimplifiedArchitecture','MinimalDataModel','ManualVsAutomated','Phase2Enhancements','TechnicalReference'];
          const allKeys = Object.keys(designSections);
          const orderedKeys = sectionOrder.filter(k => designSections[k]);
          const extraKeys = allKeys.filter(k => !sectionOrder.includes(k));
          const renderKeys = orderedKeys.concat(extraKeys);
        %>
        <% renderKeys.forEach(key => { %>
          <% if (designSections[key]) { %>
            <div class="design-item <%= fullWidthSections.includes(key) ? 'full-width' : '' %>">
              <h4><%= sectionLabels[key] || key.replace(/([A-Z])/g, ' $1').trim() %></h4>
              <div class="section-body"><%- renderText(designSections[key]) %></div>
            </div>
          <% } %>
        <% }) %>
      </div>
    <% } else { %>
      <div style="text-align:center;padding:40px;color:var(--text-muted);"><%- design.designHtml || '<p>No design content available.</p>' %></div>
    <% } %>

    <!-- Flowchart -->
    <% if (design.flowchart) { %>
    <div class="section-card">
      <h3><span class="icon">üó∫Ô∏è</span> User Journey</h3>
      <div style="display:flex;gap:6px;margin-bottom:12px;">
        <button onclick="zoomFlowchart(0.2)" style="padding:4px 12px;border:1px solid var(--border-glass);border-radius:8px;background:var(--bg-card);cursor:pointer;font-size:14px;color:var(--text-secondary);transition:all 0.2s;" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border-glass)';this.style.color='var(--text-secondary)'" title="Zoom In">‚ûï</button>
        <button onclick="zoomFlowchart(-0.2)" style="padding:4px 12px;border:1px solid var(--border-glass);border-radius:8px;background:var(--bg-card);cursor:pointer;font-size:14px;color:var(--text-secondary);transition:all 0.2s;" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border-glass)';this.style.color='var(--text-secondary)'" title="Zoom Out">‚ûñ</button>
        <button onclick="zoomFlowchart(0)" style="padding:4px 12px;border:1px solid var(--border-glass);border-radius:8px;background:var(--bg-card);cursor:pointer;font-size:14px;color:var(--text-secondary);transition:all 0.2s;" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border-glass)';this.style.color='var(--text-secondary)'" title="Reset Zoom">‚Ü∫ Reset</button>
        <button onclick="popOutFlowchart()" style="padding:4px 12px;border:1px solid var(--border-glass);border-radius:8px;background:var(--bg-card);cursor:pointer;font-size:14px;color:var(--text-secondary);transition:all 0.2s;" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border-glass)';this.style.color='var(--text-secondary)'" title="Open in new window">‚ßâ Pop Out</button>
      </div>
      <div id="flowchartRender" style="height:50vh;overflow:auto;padding:16px;border:1px solid var(--border-glass);border-radius:10px;background:#1a2d47;position:relative;display:flex;"></div>
    </div>
    <% } %>

    <!-- Customer Questions -->
    <div class="section-card">
      <h3><span class="icon">‚ùì</span> Questions for You</h3>
      <%
        const customerQuestions = (design.questions || []).filter(q => {
          return (typeof q === 'object' && q.assignedTo === 'customer');
        });
      %>
      <% if (customerQuestions.length === 0) { %>
        <div style="text-align:center;padding:24px;color:var(--text-muted);font-size:0.88rem;">No questions assigned to you at this time.</div>
      <% } else { %>
        <% customerQuestions.forEach(function(q, i) { %>
          <%
            const qText = q.text || String(q);
            const qId = q.id || (i+1);
            const qAssumption = q.assumption || '';
            const custAnswered = (design.customerAnswers || []).find(a => a.question === qText);
          %>
          <div class="question-card">
            <div>
              <span class="q-id"><%= qId %></span>
              <span class="q-text"><%= qText %></span>
            </div>
            <% if (qAssumption) { %>
              <div class="q-assumption">üí° <%= qAssumption %></div>
            <% } %>
            <% if (custAnswered) { %>
              <div class="q-answer">‚úÖ <strong>Your answer:</strong> <%= custAnswered.answer %> <span style="font-size:0.72rem;color:var(--text-muted)">‚Äî <%= melb(custAnswered.ts) %></span></div>
            <% } else { %>
              <form method="POST" action="/customer/projects/<%= encodeId(projectId) %>/design/answer" class="answer-form">
                <input type="hidden" name="designId" value="<%= design.id %>" />
                <input type="hidden" name="question" value="<%= qText %>" />
                <input type="text" name="answer" placeholder="Type your answer‚Ä¶" required />
                <button type="submit" class="btn btn-primary btn-sm">Submit</button>
              </form>
            <% } %>
          </div>
        <% }) %>
      <% } %>
    </div>
  </main>

  <!-- Tab switching -->
  <script>
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
    });
  });
  </script>

  <% if (design.flowchart || (hasNewFormat && customerDesign && customerDesign.HowItWorks)) { %>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      themeVariables: {
        primaryColor: '#1e3a5f', primaryTextColor: '#f0f4f8', primaryBorderColor: '#3399ff',
        lineColor: '#3399ff', secondaryColor: '#1a3352', tertiaryColor: '#1e3a5f',
        fontFamily: 'Inter, system-ui, -apple-system, sans-serif', fontSize: '14px',
        nodeBorder: '#3399ff', mainBkg: '#1e3a5f', clusterBkg: '#142640',
        clusterBorder: 'rgba(255,255,255,0.15)', edgeLabelBackground: '#1a3352',
        nodeTextColor: '#f0f4f8'
      }
    });

    <% if (hasNewFormat && customerDesign && customerDesign.HowItWorks) { %>
    (function() {
      const text = `<%- (customerDesign.HowItWorks || '').replace(/`/g, '\\`').replace(/\\/g, '\\\\') %>`;
      const container = document.getElementById('howItWorksFlow');
      if (!container || !text) return;
      const lines = text.split('\n');
      const steps = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const m = line.match(/^(\d+)\.\s+\*\*(.+?)\*\*\s*[-‚Äî:]*\s*(.*)/);
        if (m) {
          let desc = m[3].trim();
          if (!desc) {
            for (let j = i+1; j < Math.min(i+4, lines.length); j++) {
              const next = lines[j].trim();
              if (next && !next.match(/^\d+\./)) { desc = next.replace(/^[-‚Ä¢]\s*/, ''); break; }
            }
          }
          steps.push({ num: m[1], title: m[2], desc: desc.substring(0, 200) });
        }
      }
      if (steps.length === 0) {
        container.style.paddingLeft = '0';
        container.className = 'section-body';
        container.innerHTML = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
        return;
      }
      container.innerHTML = steps.map(s =>
        '<div class="step-item">' +
          '<div class="step-num">' + s.num + '</div>' +
          '<div class="step-title">' + s.title + '</div>' +
          (s.desc ? '<div class="step-desc">' + s.desc + '</div>' : '') +
        '</div>'
      ).join('');
    })();
    <% } %>

    // Flowchart viewer ‚Äî native scroll with SVG resize
    let fcNaturalW = 0, fcNaturalH = 0, fcScale = 1, fcFitScale = 1;

    function fcApplyScale(newScale, clientX, clientY) {
      const el = document.getElementById('flowchartRender');
      const svg = el && el.querySelector('svg');
      if (!svg || !el) return;
      const oldScale = fcScale;
      fcScale = Math.max(0.1, Math.min(10, newScale));
      let svgX, svgY;
      if (clientX !== undefined) {
        const svgRect = svg.getBoundingClientRect();
        svgX = (clientX - svgRect.left) / oldScale;
        svgY = (clientY - svgRect.top) / oldScale;
      }
      svg.style.width = (fcNaturalW * fcScale) + 'px';
      svg.style.height = (fcNaturalH * fcScale) + 'px';
      if (clientX !== undefined) {
        const newSvgRect = svg.getBoundingClientRect();
        el.scrollLeft += (newSvgRect.left + svgX * fcScale) - clientX;
        el.scrollTop += (newSvgRect.top + svgY * fcScale) - clientY;
      }
    }

    function fitFlowchartToContainer() {
      const el = document.getElementById('flowchartRender');
      const svg = el && el.querySelector('svg');
      if (!svg || !el || !fcNaturalW) return;
      const pad = 32;
      if (svg.getAttribute('data-snake-reflow')) {
        // Snake-reflowed: viewBox AR matches container, so Math.min fills nearly 100%
        const sPad = 4;
        fcFitScale = Math.min((el.clientWidth - sPad) / fcNaturalW, (el.clientHeight - sPad) / fcNaturalH, 2);
        fcScale = fcFitScale;
        const renderedH = fcNaturalH * fcScale;
        svg.style.width = (fcNaturalW * fcScale) + 'px';
        svg.style.height = renderedH + 'px';
        // Center vertically if shorter than container
        if (renderedH < el.clientHeight - pad) {
          svg.style.marginTop = ((el.clientHeight - renderedH) / 2) + 'px';
          svg.style.marginLeft = 'auto';
          svg.style.marginRight = 'auto';
          svg.style.marginBottom = '0';
        } else {
          svg.style.margin = 'auto';
        }
      } else {
        fcFitScale = Math.min((el.clientWidth - pad) / fcNaturalW, (el.clientHeight - pad) / fcNaturalH, 2);
        fcScale = fcFitScale;
        svg.style.width = (fcNaturalW * fcScale) + 'px';
        svg.style.height = (fcNaturalH * fcScale) + 'px';
        svg.style.margin = 'auto';
      }
      el.scrollLeft = 0;
      el.scrollTop = 0;
    }

    function zoomFlowchart(delta) {
      if (delta === 0) { fitFlowchartToContainer(); return; }
      const el = document.getElementById('flowchartRender');
      if (!el) return;
      const rect = el.getBoundingClientRect();
      fcApplyScale(fcScale * (delta > 0 ? 1.25 : 0.8), rect.left + rect.width / 2, rect.top + rect.height / 2);
    }

    function initFlowchartSvg() {
      const el = document.getElementById('flowchartRender');
      const svg = el && el.querySelector('svg');
      if (!svg) return;
      const vb = svg.getAttribute('viewBox');
      if (vb) {
        const parts = vb.split(/[\s,]+/).map(Number);
        fcNaturalW = parts[2] || 800;
        fcNaturalH = parts[3] || 600;
      } else {
        const w = svg.getAttribute('width'), h = svg.getAttribute('height');
        if (w && !String(w).includes('%')) fcNaturalW = parseFloat(w);
        if (h && !String(h).includes('%')) fcNaturalH = parseFloat(h);
        if (!fcNaturalW || !fcNaturalH) {
          const r = svg.getBoundingClientRect();
          fcNaturalW = fcNaturalW || r.width || 800;
          fcNaturalH = fcNaturalH || r.height || 600;
        }
      }
      svg.removeAttribute('width');
      svg.removeAttribute('height');
      svg.style.maxWidth = 'none';
      svg.style.display = 'block';
      svg.style.margin = 'auto';
      svg.style.flexShrink = '0';
      fitFlowchartToContainer();
    }

    function reflowFlowchartToSnake(code) {
      try {
        const el = document.getElementById('flowchartRender');
        const svg = el && el.querySelector('svg');
        if (!svg || !code || !/^(flowchart|graph)\s+LR/im.test(code.trim())) return;

        const palette = {
          action:   { fill: '#234b73', stroke: '#5cb3ff', text: '#e8f0fe' },
          decision: { fill: '#3b2466', stroke: '#b49aff', text: '#ede4ff' },
          terminal: { fill: '#1e5a3a', stroke: '#4ade80', text: '#dcfce7' },
        };
        const ns = 'http://www.w3.org/2000/svg';
        const FONT = 15, LINE_H = 20, PAD_H = 22, PAD_V = 16;

        // --- Text measurement via canvas ---
        const measureCanvas = document.createElement('canvas').getContext('2d');
        measureCanvas.font = '600 ' + FONT + 'px Inter, system-ui, sans-serif';
        function measureText(str) { return measureCanvas.measureText(str).width; }

        // --- Word-wrap into lines that fit maxW ---
        function wrapText(str, maxW) {
          const words = str.split(' ');
          const lines = []; let line = '';
          for (const w of words) {
            const test = line ? line + ' ' + w : w;
            if (measureText(test) > maxW && line) { lines.push(line); line = w; }
            else line = test;
          }
          if (line) lines.push(line);
          return lines;
        }

        // --- Parse edges + node shape hints from mermaid code ---
        const mLines = code.trim().split('\n');
        const edgeList = [], nodeShapeHint = {};
        for (let i = 1; i < mLines.length; i++) {
          const t = mLines[i].trim();
          if (!t || t.startsWith('%%')) continue;
          const defMatch = t.match(/^([A-Za-z]\w*)\s*(\{|(\(\[)|\[|\(\(|\()/);
          if (defMatch) {
            const nid = defMatch[1], opener = defMatch[2];
            if (opener === '{') nodeShapeHint[nid] = 'decision';
            else if (opener === '([') nodeShapeHint[nid] = 'terminal';
            else if (opener === '((' || opener === '(') nodeShapeHint[nid] = 'terminal';
            else nodeShapeHint[nid] = 'action';
          }
          if (!t.includes('-->')) continue;
          const segs = t.split(/(-->(?:\|[^|]*\|)?)/);
          const nds = [], arrs = [];
          for (let j = 0; j < segs.length; j++) {
            const s = segs[j].trim();
            if (!s) continue;
            if (s.startsWith('-->')) { arrs.push(s); continue; }
            const m = s.match(/^([A-Za-z]\w*)/);
            if (m) nds.push(m[1]);
          }
          for (let j = 0; j < arrs.length; j++) {
            if (nds[j] && nds[j+1]) {
              const lm = arrs[j].match(/\|([^|]*)\|/);
              edgeList.push({ from: nds[j], to: nds[j+1], label: lm ? lm[1].replace(/"/g, '') : '' });
            }
          }
        }
        if (edgeList.length < 4) return;

        // --- Build adjacency + ordered chain ---
        const adj = {}, inDeg = {}, allIds = [], seen = {};
        edgeList.forEach(e => {
          [e.from, e.to].forEach(id => { if (!seen[id]) { allIds.push(id); seen[id] = true; } });
          if (!adj[e.from]) adj[e.from] = [];
          adj[e.from].push(e);
          inDeg[e.to] = (inDeg[e.to] || 0) + 1;
          if (!(e.from in inDeg)) inDeg[e.from] = 0;
        });
        const start = allIds.find(id => !inDeg[id]) || allIds[0];
        const chain = [], vis = {};
        let cur = start;
        while (cur && !vis[cur]) { vis[cur] = true; chain.push(cur); cur = adj[cur]?.[0]?.to; }
        allIds.forEach(id => { if (!vis[id]) chain.push(id); });
        if (chain.length <= 4) return;

        // --- Extract labels + types from mermaid rendered SVG ---
        const nodeEls = {};
        svg.querySelectorAll('g[id]').forEach(g => {
          const m = g.id.match(/^flowchart-(\w+)-\d+$/);
          if (m) nodeEls[m[1]] = g;
        });
        if (chain.filter(id => nodeEls[id]).length < chain.length * 0.5) return;

        const nodeType = {}, nodeLabel = {};
        chain.forEach(id => {
          if (nodeShapeHint[id]) nodeType[id] = nodeShapeHint[id];
          else if (nodeEls[id] && nodeEls[id].querySelector('polygon')) nodeType[id] = 'decision';
          else if (nodeEls[id] && nodeEls[id].querySelector('circle')) nodeType[id] = 'terminal';
          else {
            const r = nodeEls[id] && nodeEls[id].querySelector('rect');
            nodeType[id] = (r && parseFloat(r.getAttribute('rx') || 0) > 15) ? 'terminal' : 'action';
          }
          if (nodeEls[id]) {
            const fo = nodeEls[id].querySelector('foreignObject');
            nodeLabel[id] = fo ? fo.textContent.trim() : (nodeEls[id].querySelector('text') || {}).textContent || id;
          } else { nodeLabel[id] = id; }
        });

        // --- Layout: compute cell sizes, pick perRow ---
        const containerW = el.clientWidth || 800;
        const containerH = el.clientHeight || 400;
        const containerAR = containerW / containerH;
        const gapX = 48, gapY = 60;
        const maxTextW = (containerW / 4.5) - PAD_H * 2 - gapX;

        const nodeDim = {};
        let maxNodeW = 0, maxNodeH = 0;
        chain.forEach(id => {
          const lines = wrapText(nodeLabel[id], maxTextW);
          const textBlockW = Math.max(...lines.map(l => measureText(l)));
          const textBlockH = lines.length * LINE_H;
          let w, h;
          if (nodeType[id] === 'decision') {
            w = (textBlockW + PAD_H * 2) * 1.35;
            h = (textBlockH + PAD_V * 2) * 1.35;
          } else {
            w = textBlockW + PAD_H * 2;
            h = textBlockH + PAD_V * 2;
          }
          nodeDim[id] = { w, h, lines };
          maxNodeW = Math.max(maxNodeW, w);
          maxNodeH = Math.max(maxNodeH, h);
        });

        const cellW = maxNodeW + gapX, cellH = maxNodeH + gapY;
        let perRow = 4, bestDiff = Infinity;
        for (let pr = 3; pr <= 8; pr++) {
          const nr = Math.ceil(chain.length / pr);
          const gridAR = (pr * cellW) / (nr * cellH);
          if (Math.abs(gridAR - containerAR) < bestDiff) { bestDiff = Math.abs(gridAR - containerAR); perRow = pr; }
        }

        const rows = [];
        for (let i = 0; i < chain.length; i += perRow) rows.push(chain.slice(i, i + perRow));
        const numRows = rows.length;
        const padX = maxNodeW / 2 + 30, padY = maxNodeH / 2 + 30;
        const gridW = perRow * cellW + padX * 2;
        const naturalH = numRows * cellH + padY * 2;
        const targetH = gridW / containerAR;
        const finalCellH = (targetH > naturalH && numRows > 1)
          ? cellH + (targetH - naturalH) / numRows : cellH;
        const vbW = gridW, vbH = numRows * finalCellH + padY * 2;

        const nodeHW = {}, nodeHH = {};
        chain.forEach(id => {
          nodeHW[id] = (nodeDim[id] ? nodeDim[id].w : maxNodeW) / 2 + 2;
          nodeHH[id] = (nodeDim[id] ? nodeDim[id].h : maxNodeH) / 2 + 2;
        });

        const pos = {};
        rows.forEach((row, ri) => {
          const isLastPartial = (ri === rows.length - 1 && row.length < perRow);
          row.forEach((id, ci) => {
            const col = (ri % 2 === 0 || isLastPartial) ? ci : (perRow - 1 - ci);
            pos[id] = { x: padX + col * cellW, y: padY + ri * finalCellH };
          });
        });

        // --- Build SVG ---
        const newSvg = document.createElementNS(ns, 'svg');
        newSvg.setAttribute('xmlns', ns);
        const defs = document.createElementNS(ns, 'defs');
        const arrowColors = { blue: '#3399ff', green: '#4ade80', red: '#ff7b72' };
        Object.keys(arrowColors).forEach(name => {
          const m = document.createElementNS(ns, 'marker');
          m.id = 'snake-arrow-' + name;
          m.setAttribute('viewBox', '0 0 10 10');
          m.setAttribute('refX', '9'); m.setAttribute('refY', '5');
          m.setAttribute('markerWidth', '8'); m.setAttribute('markerHeight', '8');
          m.setAttribute('orient', 'auto');
          const p = document.createElementNS(ns, 'path');
          p.setAttribute('d', 'M0 1 L8 5 L0 9z'); p.setAttribute('fill', arrowColors[name]);
          m.appendChild(p); defs.appendChild(m);
        });
        newSvg.appendChild(defs);
        const mainG = document.createElementNS(ns, 'g');
        newSvg.appendChild(mainG);

        const gridCenterX = chain.reduce((s, id) => s + (pos[id] ? pos[id].x : 0), 0) / chain.length;

        const edgeInfo = edgeList.map(e => {
          const f = pos[e.from], t = pos[e.to];
          if (!f || !t) return null;
          const sameRow = Math.abs(f.y - t.y) < 5, sameCol = Math.abs(f.x - t.x) < 5;
          let exitSide, enterSide;
          if (sameRow) {
            exitSide = f.x < t.x ? 'right' : 'left';
            enterSide = f.x < t.x ? 'left' : 'right';
          } else {
            exitSide = f.y < t.y ? 'bottom' : 'top';
            enterSide = f.y < t.y ? 'top' : 'bottom';
          }
          let color = 'blue', colorHex = '#3399ff';
          if (e.label && nodeType[e.from] === 'decision') {
            const ll = e.label.toLowerCase().trim();
            if (/^(yes|true|approv)/.test(ll)) { color = 'green'; colorHex = '#4ade80'; }
            else if (/^(no|false|reject)/.test(ll)) { color = 'red'; colorHex = '#ff7b72'; }
          }
          return { from: e.from, to: e.to, label: e.label, sameRow, sameCol, exitSide, enterSide, color, colorHex };
        });

        const outGroups = {};
        edgeInfo.forEach((ei, i) => { if (!ei) return; const k = ei.from+'-'+ei.exitSide; if (!outGroups[k]) outGroups[k] = []; outGroups[k].push(i); });
        const outOff = {};
        Object.values(outGroups).forEach(g => { if (g.length <= 1) return; g.forEach((idx, i) => { outOff[idx] = (i - (g.length-1)/2) * 20; }); });

        const inGroups = {};
        edgeInfo.forEach((ei, i) => { if (!ei) return; const k = ei.to+'-'+ei.enterSide; if (!inGroups[k]) inGroups[k] = []; inGroups[k].push(i); });
        const inOff = {};
        Object.values(inGroups).forEach(g => { if (g.length <= 1) return; g.forEach((idx, i) => { inOff[idx] = (i - (g.length-1)/2) * 20; }); });

        // --- Draw edges ---
        edgeInfo.forEach((ei, idx) => {
          if (!ei) return;
          const f = pos[ei.from], t = pos[ei.to];
          const fhw = nodeHW[ei.from] || maxNodeW/2, fhh = nodeHH[ei.from] || maxNodeH/2;
          const thw = nodeHW[ei.to] || maxNodeW/2, thh = nodeHH[ei.to] || maxNodeH/2;
          const oOff = outOff[idx] || 0, iOff = inOff[idx] || 0;
          const path = document.createElementNS(ns, 'path');
          path.setAttribute('stroke', ei.colorHex); path.setAttribute('stroke-width', '2');
          path.setAttribute('stroke-opacity', '0.6'); path.setAttribute('fill', 'none');
          path.setAttribute('marker-end', 'url(#snake-arrow-'+ei.color+')');
          let d, lx, ly;
          if (ei.sameRow) {
            const goR = f.x < t.x;
            const x1 = f.x + (goR ? fhw : -fhw), x2 = t.x + (goR ? -thw : thw);
            const fy = f.y + oOff, ty = t.y + iOff;
            d = 'M'+x1+','+fy+' L'+x2+','+ty;
            const lineLen = Math.abs(x2 - x1);
            if (ei.label && measureText(ei.label) + 20 > lineLen * 0.8) {
              lx = f.x; ly = f.y - fhh - 12;
            } else {
              lx = (x1 + x2) / 2; ly = Math.min(fy, ty) - 12;
            }
          } else if (ei.sameCol) {
            const goD = f.y < t.y;
            const y1 = f.y + (goD ? fhh : -fhh), y2 = t.y + (goD ? -thh : thh);
            const fx = f.x + oOff;
            d = 'M'+fx+','+y1+' L'+fx+','+y2;
            const labelLeft = f.x > gridCenterX;
            lx = f.x + (labelLeft ? -(fhw + 8) : (fhw + 8));
            ly = (y1 + y2) / 2;
          } else {
            const goD = f.y < t.y;
            const exitY = f.y + (goD ? fhh : -fhh), enterY = t.y + (goD ? -thh : thh);
            const srcRi = rows.findIndex(row => row.includes(ei.from));
            const tgtRi = rows.findIndex(row => row.includes(ei.to));
            let midY;
            if (Math.abs(tgtRi - srcRi) <= 1 || srcRi < 0 || tgtRi < 0) {
              midY = (f.y + t.y) / 2 + oOff;
            } else {
              const nextRi = goD ? srcRi + 1 : srcRi - 1;
              const nextRowY = padY + nextRi * finalCellH;
              midY = (f.y + nextRowY) / 2 + oOff;
            }
            const dirX = t.x > f.x ? 1 : -1, dirY = goD ? 1 : -1;
            const fx = f.x + oOff, tx = t.x + iOff;
            const r = Math.min(14, Math.abs(midY - exitY)/2, Math.abs(midY - enterY)/2);
            d = 'M'+fx+','+exitY+' L'+fx+','+(midY-dirY*r)
              +' Q'+fx+','+midY+' '+(fx+dirX*r)+','+midY
              +' L'+(tx-dirX*r)+','+midY
              +' Q'+tx+','+midY+' '+tx+','+(midY+dirY*r)
              +' L'+tx+','+enterY;
            lx = (f.x + t.x) / 2; ly = midY - 14;
          }
          path.setAttribute('d', d); mainG.appendChild(path);
          if (ei.label) {
            const LFONT = 14;
            measureCanvas.font = '600 '+LFONT+'px Inter, system-ui, sans-serif';
            const tw = measureText(ei.label) + 16;
            measureCanvas.font = '600 '+FONT+'px Inter, system-ui, sans-serif';
            const lh = 20;
            const bg = document.createElementNS(ns, 'rect');
            bg.setAttribute('x', lx-tw/2); bg.setAttribute('y', ly-lh/2);
            bg.setAttribute('width', tw); bg.setAttribute('height', lh);
            bg.setAttribute('rx', '4'); bg.setAttribute('fill', '#152a45');
            bg.setAttribute('fill-opacity', '0.95');
            bg.setAttribute('stroke', ei.colorHex); bg.setAttribute('stroke-width', '0.7');
            bg.setAttribute('stroke-opacity', '0.5');
            mainG.appendChild(bg);
            const txt = document.createElementNS(ns, 'text');
            txt.setAttribute('x', lx); txt.setAttribute('y', ly + 5);
            txt.setAttribute('text-anchor', 'middle'); txt.setAttribute('font-size', LFONT);
            txt.setAttribute('font-weight', '600');
            txt.setAttribute('font-family', 'Inter,-apple-system,sans-serif');
            txt.setAttribute('fill', ei.color === 'blue' ? '#e0ecff' : ei.colorHex);
            txt.textContent = ei.label; mainG.appendChild(txt);
          }
        });

        // --- Draw custom nodes (no cloning) ---
        chain.forEach(id => {
          if (!pos[id] || !nodeDim[id]) return;
          const { w, h, lines } = nodeDim[id];
          const type = nodeType[id] || 'action';
          const pal = palette[type];
          const g = document.createElementNS(ns, 'g');
          g.setAttribute('transform', 'translate('+pos[id].x+','+pos[id].y+')');

          if (type === 'decision') {
            const poly = document.createElementNS(ns, 'polygon');
            poly.setAttribute('points', '0,'+(-h/2)+' '+(w/2)+',0 0,'+(h/2)+' '+(-w/2)+',0');
            poly.setAttribute('fill', pal.fill); poly.setAttribute('stroke', pal.stroke);
            poly.setAttribute('stroke-width', '2.5'); g.appendChild(poly);
          } else {
            const rect = document.createElementNS(ns, 'rect');
            rect.setAttribute('x', -w/2); rect.setAttribute('y', -h/2);
            rect.setAttribute('width', w); rect.setAttribute('height', h);
            rect.setAttribute('rx', type === 'terminal' ? h/2 : 8);
            rect.setAttribute('fill', pal.fill); rect.setAttribute('stroke', pal.stroke);
            rect.setAttribute('stroke-width', '2.5'); g.appendChild(rect);
          }

          const blockH = lines.length * LINE_H;
          lines.forEach((line, i) => {
            const txt = document.createElementNS(ns, 'text');
            txt.setAttribute('x', '0');
            txt.setAttribute('y', -blockH/2 + (i + 0.75) * LINE_H);
            txt.setAttribute('text-anchor', 'middle');
            txt.setAttribute('font-size', FONT + 'px');
            txt.setAttribute('font-weight', '600');
            txt.setAttribute('font-family', 'Inter,-apple-system,sans-serif');
            txt.setAttribute('fill', pal.text);
            txt.textContent = line; g.appendChild(txt);
          });
          mainG.appendChild(g);
        });

        // Tight viewBox matching container AR so it fills the box exactly
        let bx0 = Infinity, by0 = Infinity, bx1 = -Infinity, by1 = -Infinity;
        chain.forEach(id => {
          if (!pos[id] || !nodeDim[id]) return;
          const hw = nodeDim[id].w / 2, hh = nodeDim[id].h / 2;
          bx0 = Math.min(bx0, pos[id].x - hw); bx1 = Math.max(bx1, pos[id].x + hw);
          by0 = Math.min(by0, pos[id].y - hh); by1 = Math.max(by1, pos[id].y + hh);
        });
        const cp = 50;
        let vbX = bx0 - cp, vbY = by0 - cp;
        let vbFW = bx1 - bx0 + cp * 2, vbFH = by1 - by0 + cp * 2;
        // Expand shorter dimension to match container AR (centers content)
        const contentAR = vbFW / vbFH;
        if (contentAR > containerAR) {
          const newH = vbFW / containerAR;
          vbY -= (newH - vbFH) / 2; vbFH = newH;
        } else {
          const newW = vbFH * containerAR;
          vbX -= (newW - vbFW) / 2; vbFW = newW;
        }
        newSvg.setAttribute('viewBox', vbX+' '+vbY+' '+vbFW+' '+vbFH);
        newSvg.setAttribute('data-snake-reflow', '1');
        el.innerHTML = '';
        el.appendChild(newSvg);
      } catch(e) { console.warn('Snake reflow failed:', e); }
    }

    <% if (design.flowchart) { %>
    (async () => {
      try {
        const fcCode = `<%- design.flowchart.replace(/`/g, '\\`').replace(/\\/g, '\\\\') %>`;
        const { svg } = await mermaid.render('flowchart-svg', fcCode);
        document.getElementById('flowchartRender').innerHTML = svg;
        reflowFlowchartToSnake(fcCode);
        requestAnimationFrame(() => initFlowchartSvg());
      } catch(e) { if (document.getElementById('flowchartRender')) document.getElementById('flowchartRender').textContent = 'Flowchart rendering failed'; }
    })();
    <% } %>

    function popOutFlowchart() {
      const svg = document.querySelector('#flowchartRender svg');
      if (!svg) return;
      const clone = svg.cloneNode(true);
      clone.style.width = '';
      clone.style.height = '';
      clone.style.margin = '';
      clone.style.maxWidth = '100%';
      clone.style.flexShrink = '';
      const svgHtml = clone.outerHTML;
      const projectName = document.title || 'Flowchart';
      const win = window.open('', '_blank', 'width=1200,height=700');
      win.document.write('<!DOCTYPE html><html><head><title>' + projectName + ' ‚Äî User Journey</title><style>*{margin:0;padding:0;box-sizing:border-box}body{background:#0a1628;display:flex;align-items:center;justify-content:center;min-height:100vh;padding:24px;font-family:Inter,-apple-system,sans-serif}svg{max-width:100%;height:auto}</style></head><body>' + svgHtml + '</body></html>');
      win.document.close();
    }

    // Wheel zoom, pinch-to-zoom, double-click toggle
    (function() {
      const el = document.getElementById('flowchartRender');
      if (!el) return;

      el.addEventListener('wheel', function(e) {
        if (!el.querySelector('svg')) return;
        if (!e.ctrlKey) return; // Let normal 2-finger scroll pan natively; only intercept pinch-zoom
        e.preventDefault();
        fcApplyScale(fcScale * (e.deltaY > 0 ? 0.9 : 1.1), e.clientX, e.clientY);
      }, { passive: false });

      let lastPinchDist = 0;
      el.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
          lastPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }
      });
      el.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2) {
          e.preventDefault();
          const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
          const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          fcApplyScale(fcScale * (dist / lastPinchDist), midX, midY);
          lastPinchDist = dist;
        }
      }, { passive: false });

      el.addEventListener('dblclick', function() {
        if (Math.abs(fcScale - fcFitScale) < 0.01) {
          const rect = el.getBoundingClientRect();
          fcApplyScale(1, rect.left + rect.width / 2, rect.top + rect.height / 2);
        } else {
          fitFlowchartToContainer();
        }
      });
    })();
  </script>
  <% } %>
</body>
</html>